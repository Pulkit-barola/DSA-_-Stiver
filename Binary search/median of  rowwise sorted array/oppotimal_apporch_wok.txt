Bilkul! Yahaan source ke hisaab se **Median in a Row Wise Sorted Matrix** dhundhne ka **optimal approach** Hinglish mein explain kiya gaya hai:

---

### **Median in a Row Wise Sorted Matrix: Sabse Best Tareeka! (Optimal Approach)**

Hello dosto, aaj hum ek bahut interesting problem solve karenge jiska naam hai "Median in a Row Wise Sorted Matrix". Is problem ko sabse behtar tareeke se kaise solve kiya jaye, chalo dekhte hain!

**1. Problem Kya Hai? (Understanding the Problem)**

Humein ek **2D Matrix** diya gaya hai jiska size `n x m` hai. Yahaan, `n` (rows) aur `m` (columns) dono **odd integers** hain. Jab do odd numbers ko multiply karte hain, toh total elements bhi odd hi honge (jaise 3x5 = 15 elements).

Sabse khaas baat yeh hai ki yeh matrix **row-wise sorted** hai. Iska matlab hai ki matrix ki har ek row alag se sorted hai (jaise `` ek row hai toh yeh sorted hai, `` doosri row hai toh yeh bhi sorted hai).

Humein is matrix mein saare elements ka **Median** dhundhna hai. Median kya hota hai? **Median woh middle value hoti hai ek sorted set of numbers mein**. Agar hum saare elements ko ek linear list mein sorted order mein likhein, toh jo bilkul beech wala element hoga, woh hamara median hai. Jaise, agar total 15 elements hain, toh sorted list mein 7 elements left mein aur 7 elements right mein honge, aur 8th element median hoga.

**2. Brute Force (Simple par Slow!)**

Sabse pehla tareeka jo dimag mein aata hai, woh yeh hai:
*   Matrix ke saare elements ko ek **1D Array** mein copy kar lo.
*   Is 1D Array ko **sort** kar do.
*   Phir, median dhundhne ke liye, `(n * m) / 2` index pe jo value hai, woh return kar do. (Integer division `15/2 = 7` ho jayega, 0-indexed list mein 7th index ka element median hoga).

**Time Complexity:** Isme pehle saare elements ko copy karne mein `O(n*m)` lagega, aur phir sorting mein `O(n*m * log(n*m))` lagega. Toh total **`O(n*m * log(n*m))`** ho jayegi. Interviewer is solution se khush nahi hoga aur bolega "Optimize karo!".

**3. Optimal Approach: Binary Search ka Jaadu!**

Jab bhi sorted data ya median jaisi cheez dhundhni ho, aur simple approach slow ho, toh **Binary Search** ke baare mein socho! Yahaan hum **answer par hi binary search** karenge. Matlab, hum values ke range mein search karenge, na ki matrix ke indices par.

**A. Search Space Define Karna (Defining the Search Space)**

*   Hamara answer (median) kahan se kahan tak ho sakta hai? Woh **matrix ke sabse chote element se lekar sabse bade element ke beech** mein hoga.
*   **Low (Sabse chota value):** Matrix ki har row ka pehla element dekho (`matrix[i]`). Un sab mein se jo sabse chota hoga, woh hamara `low` ban jayega.
*   **High (Sabse bada value):** Matrix ki har row ka aakhri element dekho (`matrix[i][m-1]`). Un sab mein se jo sabse bada hoga, woh hamara `high` ban jayega.
*   Constraints ke hisaab se, yeh values `1` se lekar `10^9` tak ho sakti hain.

**B. Kitne Elements Chahiye? (Required Count)**

*   Humein total `n*m` elements mein se median dhundhna hai.
*   Median woh value `X` hai jiske left mein exactly `(n*m)/2` elements hon aur right mein bhi `(n*m)/2` elements hon.
*   Isliye, humein ek aisi value `X` chahiye, jiske **smaller than or equal to** elements ka count `(n*m)/2` se **zyada** ho, aur woh pehla aisi value ho. Let's say `required = (n*m)/2`.

**C. Main Binary Search Logic**

Ab `low` aur `high` define ho gaye hain, toh binary search lagate hain:

```
while (low <= high):
    mid = low + (high - low) / 2  // Middle value calculate karo
    
    // Yahan hum ek "Black Box" function call karenge
    // Yeh function batayega ki 'mid' se chote ya barabar kitne elements hain
    smallEquals = countSmallerEquals(matrix, mid) // Black Box call
    
    if (smallEquals <= required): // Agar count kam hai ya barabar hai required ke
        // Iska matlab 'mid' bahut chota hai, ya bas utne hi elements hain.
        // Humein aur bade values mein search karna padega.
        low = mid + 1 // Search space ko right side mein shift karo
    else: // Agar count 'required' se zyada hai (humne apna target cross kar diya)
        // Iska matlab 'mid' ek potential answer ho sakta hai,
        // ya humein 'mid' se chota koi aur value mil sakta hai jo condition satisfy kare.
        // Toh hum answer store kar lenge aur left side mein search karenge.
        ans = mid // Current mid ko answer maan lo (optional, but good for tracking)
        high = mid - 1 // Search space ko left side mein shift karo
        
// Jab loop khatam hoga (low > high), toh 'low' hi hamara final answer hoga.
return low
```

**4. The "Black Box" Function: `countSmallerEquals(matrix, x)`**

Yeh function bahut important hai. Iska kaam hai, diye gaye matrix aur ek value `x` ke liye, yeh batana ki **kitne elements matrix mein `x` se chote ya barabar hain**.

Yeh function `O(n*m)` mein bhi ban sakta hai (saare elements iterate karke), lekin hum ise **optimize** karenge binary search ka use karke.

*   **Logic:**
    1.  `count = 0` se initialize karo.
    2.  Matrix ki **har row** (`i` from `0` to `n-1`) mein iterate karo.
    3.  Har row (jo already sorted hai) par **`upper_bound`** function lagao `x` value ke liye.
        *   `upper_bound(row, x)` ek iterator return karta hai jo **`x` se pehla bada element** ko point karta hai.
        *   Agar `upper_bound` ne `matrix[i][j]` ko point kiya, toh iska matlab hai ki `j` elements (index `0` se `j-1` tak) `x` se chote ya barabar hain is row mein.
        *   Toh, `upper_bound` jo index return karega, wahi hamare **`x` se chote ya barabar elements ka count** hai us particular row mein.
    4.  Is count ko `total count` mein add karte jao.
    5.  Saari rows iterate karne ke baad, **`total count`** return kar do.

*   **Time Complexity of Black Box:** Har row mein `upper_bound` ek binary search hai jo `O(log m)` time leta hai (kyunki row ki length `m` hai). Aise `n` rows hain, toh total **`O(n * log m)`** ho jayega.

**5. Total Time Complexity (Kitna Fast Hai Apna Solution?)**

*   Outer binary search `log(max_value - min_value)` times chalta hai. Max value `10^9` tak ho sakti hai, toh yeh `log(10^9)` ke around hoga.
*   Har step mein hum `Black Box` function call karte hain, jiska time `O(n * log m)` hai.

Toh, **overall time complexity** ho jayegi: **`O(log(10^9) * n * log m)`**.

Yeh solution Brute Force se kaafi zyada fast hai aur interviews mein yahi expect kiya jata hai! I hope aapko yeh approach acche se samajh aa gaya hoga.

---